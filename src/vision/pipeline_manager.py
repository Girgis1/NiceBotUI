"""Runtime orchestration for multi-model vision pipelines."""
from __future__ import annotations

import json
import threading
import time
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Optional, Tuple

try:  # Optional heavy dependencies
    import numpy as np  # type: ignore
except ImportError:  # pragma: no cover - optional dependency
    np = None  # type: ignore

try:
    import cv2  # type: ignore
except ImportError:  # pragma: no cover - optional dependency
    cv2 = None  # type: ignore

from utils.camera_hub import CameraStreamHub  # type: ignore

from .models import MODEL_REGISTRY, VisionModelBase, VisionModelSpec


@dataclass
class SlotState:
    """Runtime bundle for a model slot."""

    spec: VisionModelSpec
    slot_config: Dict[str, any]
    model: VisionModelBase


class VisionTrainingRecorder:
    """Persist metadata generated by the vision helpers for training."""

    def __init__(self, root: Path) -> None:
        self.root = root
        self.root.mkdir(parents=True, exist_ok=True)
        self._lock = threading.Lock()

    def record_event(self, camera: str, timestamp: float, payload: Dict[str, any]) -> None:
        target = self.root / camera
        target.mkdir(parents=True, exist_ok=True)
        events_file = target / "events.jsonl"
        line = json.dumps({"timestamp": timestamp, **payload}, ensure_ascii=False)
        with self._lock:
            with events_file.open("a", encoding="utf-8") as handle:
                handle.write(line + "\n")

    def record_mask(self, camera: str, timestamp: float, mask: "np.ndarray", metadata: Dict[str, any]) -> None:  # pragma: no cover - depends on numpy
        if np is None:
            return
        target = self.root / camera / "masks"
        target.mkdir(parents=True, exist_ok=True)
        filename = target / f"{int(timestamp * 1000)}.npy"
        with self._lock:
            np.save(filename, mask)
        self.record_event(camera, timestamp, {"type": "mask", "path": str(filename), **metadata})


class VisionCameraPipeline:
    """Background worker that executes the configured models for a camera."""

    def __init__(
        self,
        manager: "VisionPipelineManager",
        camera_name: str,
        pipeline_config: Dict[str, any],
    ) -> None:
        self.manager = manager
        self.camera_name = camera_name
        self._pipeline_config = pipeline_config
        self._thread: Optional[threading.Thread] = None
        self._stop_event = threading.Event()
        self._slots: List[SlotState] = []
        self._lock = threading.Lock()
        self._last_hand_state = False
        self._build_slots()

    # ------------------------------------------------------------------
    # Lifecycle

    def start(self) -> None:
        if self._thread and self._thread.is_alive():
            return
        self._stop_event.clear()
        self._thread = threading.Thread(target=self._run_loop, name=f"vision_pipeline_{self.camera_name}", daemon=True)
        self._thread.start()

    def stop(self) -> None:
        self._stop_event.set()
        if self._thread and self._thread.is_alive():
            self._thread.join(timeout=1.5)
        self._thread = None

    # ------------------------------------------------------------------

    def update_config(self, pipeline_config: Dict[str, any]) -> None:
        with self._lock:
            self._pipeline_config = pipeline_config
            self._build_slots()

    # ------------------------------------------------------------------

    def _build_slots(self) -> None:
        slots: List[SlotState] = []
        pipeline = self._pipeline_config.get("pipeline", [])
        model_settings = self.manager.model_settings
        for slot in pipeline[:3]:
            key = slot.get("model")
            if not key or key == "none":
                continue
            spec = MODEL_REGISTRY.get(key)
            if not spec:
                continue
            slot_cfg = dict(spec.default_slot)
            slot_cfg.update(slot)
            settings = dict(spec.default_settings)
            settings.update(model_settings.get(key, {}))
            try:
                model = spec.factory(self.camera_name, slot_cfg, settings)
            except Exception as exc:  # pragma: no cover - defensive
                print(f"[VISION] Failed to build model '{key}' for {self.camera_name}: {exc}")
                continue
            slots.append(SlotState(spec=spec, slot_config=slot_cfg, model=model))
        self._slots = slots

    # ------------------------------------------------------------------

    def _fetch_frame(self) -> Tuple[Optional["np.ndarray"], float]:
        hub = self.manager.camera_hub
        if hub is None or np is None:
            return None, time.time()
        frame, ts = hub.get_frame_with_timestamp(self.camera_name, preview=False)
        if frame is None:
            return None, ts
        return frame, ts

    def _blend_frames(self, base: "np.ndarray", overlay: "np.ndarray") -> "np.ndarray":  # pragma: no cover - depends on numpy
        if np is None:
            return base
        if cv2 is not None:
            return cv2.addWeighted(base, 0.5, overlay, 0.5, 0)
        return ((base.astype(np.float32) + overlay.astype(np.float32)) / 2.0).astype(np.uint8)

    def _run_loop(self) -> None:
        while not self._stop_event.is_set():
            idle_sleep = max(float(self._pipeline_config.get("interval_s", 0.2)), 0.05)
            frame, timestamp = self._fetch_frame()
            if frame is None:
                time.sleep(idle_sleep)
                if self._last_hand_state:
                    self._last_hand_state = False
                    self.manager.handle_hand_alert(self.camera_name, False)
                continue

            render_frame = frame.copy() if np is not None else None
            overlay_active = False
            combined_status: List[str] = []
            hand_alert = False
            hand_slot_present = False

            for slot_state in list(self._slots):
                slot_cfg = slot_state.slot_config
                if not slot_cfg.get("enabled", True):
                    continue

                try:
                    model_result = slot_state.model.process(frame.copy() if np is not None else frame, timestamp)
                except Exception as exc:  # pragma: no cover - defensive
                    print(f"[VISION] Model '{slot_state.spec.key}' error on {self.camera_name}: {exc}")
                    continue

                if model_result.status_text:
                    combined_status.append(model_result.status_text)

                if slot_state.spec.key == "hand_presence":
                    hand_slot_present = hand_slot_present or slot_cfg.get("dashboard_indicator", True)
                    if slot_cfg.get("dashboard_indicator", True):
                        hand_alert = hand_alert or bool(model_result.alert)

                if model_result.mask is not None and slot_cfg.get("save_to_training"):
                    self.manager.training_recorder.record_mask(
                        self.camera_name,
                        timestamp,
                        model_result.mask,
                        {"model": slot_state.spec.key, **model_result.metadata},
                    )

                if model_result.overlay is not None and render_frame is not None:
                    render_frame = self._blend_frames(render_frame, model_result.overlay)
                    overlay_active = True

                if model_result.metadata:
                    self.manager.training_recorder.record_event(
                        self.camera_name,
                        timestamp,
                        {"type": "metadata", "model": slot_state.spec.key, **model_result.metadata},
                    )

            if hand_slot_present:
                if self._last_hand_state != hand_alert:
                    self.manager.handle_hand_alert(self.camera_name, hand_alert)
                    self._last_hand_state = hand_alert
            elif self._last_hand_state:
                self.manager.handle_hand_alert(self.camera_name, False)
                self._last_hand_state = False

            if overlay_active and render_frame is not None:
                status_text = " Â· ".join(combined_status[-3:]) if combined_status else "Vision"
                self.manager.update_overlay(self.camera_name, render_frame, status_text)
            else:
                self.manager.clear_overlay(self.camera_name)

            time.sleep(idle_sleep)


class VisionPipelineManager:
    """Singleton-style entry point used by the UI."""

    _instance: Optional["VisionPipelineManager"] = None
    _lock = threading.Lock()

    def __init__(self, config: Dict[str, any], dashboard_tab=None) -> None:
        self.dashboard_tab = dashboard_tab
        self._pipelines: Dict[str, VisionCameraPipeline] = {}
        self.model_settings: Dict[str, Dict[str, any]] = self._merge_model_settings(config)
        self.training_recorder = VisionTrainingRecorder(Path("data/training/vision"))
        try:
            self.camera_hub: Optional[CameraStreamHub] = CameraStreamHub.instance(config)
        except Exception as exc:  # pragma: no cover - optional dependency missing
            print(f"[VISION] Camera hub unavailable: {exc}")
            self.camera_hub = None
        self.update_config(config)

    # ------------------------------------------------------------------

    @classmethod
    def instance(cls, config: Dict[str, any], dashboard_tab=None) -> "VisionPipelineManager":
        with cls._lock:
            if cls._instance is None:
                cls._instance = cls(config, dashboard_tab=dashboard_tab)
            else:
                cls._instance.dashboard_tab = dashboard_tab or cls._instance.dashboard_tab
                cls._instance.update_config(config)
        return cls._instance

    # ------------------------------------------------------------------

    def _merge_model_settings(self, config: Dict[str, any]) -> Dict[str, Dict[str, any]]:
        vision_cfg = config.get("vision", {})
        settings = vision_cfg.get("model_settings", {})
        merged: Dict[str, Dict[str, any]] = {}
        for key, spec in MODEL_REGISTRY.items():
            merged[key] = dict(spec.default_settings)
            merged[key].update(settings.get(key, {}))
        return merged

    def update_config(self, config: Dict[str, any]) -> None:
        vision_cfg = config.get("vision", {})
        pipelines_cfg = vision_cfg.get("cameras", {})
        self.model_settings = self._merge_model_settings(config)

        # Update or create pipelines
        active_cameras = set()
        for camera_name, pipeline_cfg in pipelines_cfg.items():
            active_cameras.add(camera_name)
            pipeline = self._pipelines.get(camera_name)
            if pipeline is None:
                pipeline = VisionCameraPipeline(self, camera_name, pipeline_cfg)
                self._pipelines[camera_name] = pipeline
                pipeline.start()
            else:
                pipeline.update_config(pipeline_cfg)

        # Stop pipelines for cameras no longer configured
        for camera_name in list(self._pipelines.keys()):
            if camera_name not in active_cameras:
                self._pipelines[camera_name].stop()
                del self._pipelines[camera_name]

    # ------------------------------------------------------------------

    def handle_hand_alert(self, camera_name: str, active: bool) -> None:
        if self.dashboard_tab and hasattr(self.dashboard_tab, "set_hand_presence_state"):
            try:
                self.dashboard_tab.set_hand_presence_state(camera_name, active)
            except Exception as exc:  # pragma: no cover - defensive
                print(f"[VISION] Failed to propagate hand state: {exc}")

    def update_overlay(self, camera_name: str, frame: "np.ndarray", status: str) -> None:  # pragma: no cover - depends on numpy
        if np is None or self.dashboard_tab is None:
            return
        if hasattr(self.dashboard_tab, "set_vision_overlay"):
            try:
                self.dashboard_tab.set_vision_overlay(camera_name, frame, status)
            except Exception as exc:
                print(f"[VISION] Failed to push overlay: {exc}")

    def clear_overlay(self, camera_name: str) -> None:
        if self.dashboard_tab and hasattr(self.dashboard_tab, "clear_vision_overlay"):
            try:
                self.dashboard_tab.clear_vision_overlay(camera_name)
            except Exception as exc:  # pragma: no cover
                print(f"[VISION] Failed to clear overlay: {exc}")

    # ------------------------------------------------------------------

    def shutdown(self) -> None:
        for pipeline in list(self._pipelines.values()):
            pipeline.stop()
        self._pipelines.clear()
        if self.camera_hub is not None:
            try:
                self.camera_hub.shutdown()
            except Exception:
                pass


